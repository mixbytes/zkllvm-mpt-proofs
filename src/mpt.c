#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "math.h"

#include "keccak256.h"

#define STRING_SHORT_START 0x80
#define STRING_LONG_START 0xb8
#define LIST_SHORT_START 0xc0
#define LIST_LONG_START 0xf8

typedef struct {
    uint8_t* data;
    size_t length;
} Bytes;

typedef struct {
    uint32_t len;
    uint8_t* memPtr;
} RLPItem;

int compareBytes32(uint8_t a[32], uint8_t b[32]) {
    for (int i = 0 ; i < 32; i++) {
        if (a[i] != b[i]) {
            return 0;
        }
    }

    return 1;
}

void printBytes32(uint8_t a[32]) {
    for (int i = 0; i < 32; i++) {

        printf("%02x", a[i]);
    }
    printf("\n");
}

// Bytes* intToBytes(int value) {
//     Bytes *converted = (Bytes *) malloc(sizeof(Bytes));

//     converted->data = malloc(sizeof(uint8_t));
//     converted->length = 0;

//     if (value == 0) {
//         converted->data[0] = 0;
//         converted->length++;
//         return converted;
//     }

//     while (value > 0) {
//         converted->data = (uint8_t *) realloc(converted->data, converted->length + 1);

//         converted->data[converted->length++] = value & 0xF;
//         value = value / 0xF;
//     }

//     for (int i = 0; i < converted->length; i++) {
//         uint8_t temp = converted->data[converted->length - i - 1];
//         converted->data[converted->length - i - 1] = converted->data[i];
//         converted->data[i] = temp;
//     }

//     return converted;
// }

Bytes* _decodeNibbles(Bytes *compact, uint8_t skipNibbles) {                                                                        
    // CHECK compact size;                                                                                                             
                                                                                                                                       
    uint8_t length = compact->length * 2;                                                                                                       
    // CHECK assert(skipNibbles <= length);                                                                                            
    length -= skipNibbles;                                                                                                             

    Bytes *nibbles = malloc(sizeof(Bytes));                                                                                                                                
    nibbles->data = malloc(sizeof(uint8_t) * length); 
    nibbles->length = 0;                                                                                               
                                                                                                                                       
    for (uint8_t i = skipNibbles; i < skipNibbles + length; i += 1) {                                                    
        if (i % 2 == 0) {                                                                                                              
            nibbles->data[nibbles->length] = (uint8_t)((compact->data[i / 2] >> 4) & 0xF);                                                           
        } else {                                                                                                                       
            nibbles->data[nibbles->length] = (uint8_t)((compact->data[i / 2] >> 0) & 0xF);                                                           
        }                                                                                                                              
        nibbles->length += 1;                                                                                                            
    }                                                                                                                                  
                                                                                                                                       
    // CHECK assert(nibblesLength == nibbles.size());                                                                                  
                                                                                                                                       
    return nibbles;                                                                                                                    
}

void mptHashHash(RLPItem *item, uint8_t output[32]) {
    SHA3_CTX context;
    keccak_init(&context);
    
    Bytes *result = (Bytes*) malloc(sizeof(Bytes));
    result->data = (uint8_t*) malloc(sizeof(uint8_t));
    result->length = 32;

    if (item->len < 32) {
        keccak_update(&context, (const unsigned char*) (item->memPtr), (size_t) (item->len));
        keccak_final(&context, (unsigned char*) output);                                                                                                                                                                                    
    } else {                                                                                                                           
        keccak_update(&context, (const unsigned char*) (item->memPtr), (size_t) (item->len));
        keccak_final(&context, (unsigned char*) output);

        keccak_init(&context);
        keccak_update(&context, (const unsigned char*) (output), (size_t) 32);
        keccak_final(&context, (unsigned char*) output);                                                               
    }

    free(result->data);
    free(result);
    memset((char*)&context, 0, sizeof(SHA3_CTX));
}

uint32_t _payloadOffset(const uint8_t *ptr) {
    uint8_t firstByte = *ptr;

    if (firstByte < STRING_SHORT_START) {
        return 0;
    } else if (firstByte < STRING_LONG_START || (firstByte >= LIST_SHORT_START && firstByte < LIST_LONG_START)) {
        return 1;
    } else if (firstByte < LIST_SHORT_START) {
        return firstByte - (STRING_LONG_START - 1) + 1;
    } else {
        return firstByte - (LIST_LONG_START - 1) + 1;
    }
}

int isList(const RLPItem* item) {
    if (item->len == 0) return 0;

    uint8_t byte0 = item->memPtr[0];
    return byte0 >= LIST_SHORT_START;
}

uint32_t _itemLength(uint8_t *ptr) {
    uint8_t firstByte = *ptr;
    if (firstByte < STRING_SHORT_START) {
        return 1;
    } else if (firstByte < STRING_LONG_START) {
        return firstByte - STRING_SHORT_START + 1;
    } else if (firstByte < LIST_SHORT_START) {
        uint8_t lengthOfLength = firstByte - STRING_LONG_START + 1;
        // uint32_t dataLength = 0;
        // for (uint8_t i = 0; i < lengthOfLength; ++i) {
        //     dataLength = (dataLength << 8) + ptr[i + 1]; // TODO: check this
        // }

        uint32_t dataLength = *(ptr + 1) / pow(256, 32 - lengthOfLength);

        printf("Data length %d\n", 1 + lengthOfLength + dataLength);

        return 1 + lengthOfLength + dataLength;
    } else if (firstByte < LIST_LONG_START) {
        return firstByte - LIST_SHORT_START + 1;
    } else {
        uint8_t lengthOfLength = firstByte - LIST_LONG_START + 1;
        // uint32_t dataLength = 0;
        // for (uint8_t i = 0; i < lengthOfLength; ++i) {
        //     dataLength = (dataLength << 8) + ptr[i + 1];
        // }

        uint32_t dataLength = *(ptr + 1) / pow(256, 32 - lengthOfLength);

        return 1 + lengthOfLength + dataLength;
    }
}

RLPItem** toList(const RLPItem* item, uint32_t* numItems) {
    if (!isList(item)) {
        *numItems = 0;
        return NULL;
    }

    uint32_t count = 0;

    uintptr_t currPtr = (uintptr_t)(item->memPtr) + _payloadOffset(item->memPtr);
    uintptr_t endPtr = (uintptr_t)(item->memPtr) + item->len;
    
    while (currPtr < endPtr) {
        currPtr += _itemLength((uint8_t*) currPtr);
        count++;
    }

    RLPItem** list = (RLPItem**) malloc(count * sizeof(RLPItem*));
    if (list == NULL) {
        *numItems = 0;
        return NULL;
    }

    currPtr = _payloadOffset(item->memPtr);
    for (uint32_t i = 0; i < count; ++i) {
        uint32_t len = _itemLength(item->memPtr + currPtr);

        RLPItem *listItem = (RLPItem *) malloc(sizeof(RLPItem));
        listItem->memPtr = (uint8_t*) malloc(len * sizeof(uint8_t));

        memcpy(listItem->memPtr, item->memPtr + currPtr, len);
        listItem->len = len;
    
        list[i] = listItem;

        currPtr += len;
    }

    *numItems = count;
    return list;
}

uint8_t* toBytes(RLPItem* item) {
    int bytesLength = item->len;
    uint8_t* bytes = (uint8_t*)malloc(bytesLength);
    if (bytes != NULL) {
        memcpy(bytes, item->memPtr, bytesLength);
    }
    return bytes;
}

int _isEmptyBytesequence(RLPItem *item) {
    if (item->len != 1) {
        return 0;
    }

    uint8_t b;
    uint8_t *memPtr = item->memPtr;

    return *memPtr == 128;
}

void keccak256(const uint8_t* input, size_t inputLen, uint8_t output[32]) {
    SHA3_CTX context;
    keccak_init(&context);
    keccak_update(&context, (const unsigned char*) input, (size_t) inputLen);
    keccak_final(&context, (unsigned char*) output); 
}

void payloadLocation(const RLPItem* item, uint8_t** memPtr, uint32_t* len) {
    uint32_t offset = _payloadOffset(item->memPtr);
    *memPtr = item->memPtr + offset;
    *len = item->len - offset;
};

void payloadKeccak256(const RLPItem* item, uint8_t output[32]) {
    uint8_t* memPtr;
    uint32_t len;

    payloadLocation(item, &memPtr, &len);

    printBytes32(memPtr);

    keccak256(memPtr, len, output);
}

int _merklePatriciaCompactDecode(Bytes *compact, Bytes* output) {
    int isLeaf;

    int first_nibble = ((uint8_t) compact->data[0]) >> 4 & 0xF;
    int skipNibbles;
    if (first_nibble == 0) {
        skipNibbles = 2;
        isLeaf = 0;
    } else if (first_nibble == 1) {
        skipNibbles = 1;
        isLeaf = 0;
    } else if (first_nibble == 2) {
        skipNibbles = 2;
        isLeaf = 1;
    } else if (first_nibble == 3) {
        skipNibbles = 1;
        isLeaf = 1;
    } else {
        exit(-1);
    }

    output = _decodeNibbles(compact, skipNibbles);

    return isLeaf;
}

size_t _sharedPrefixLength(size_t xsOffset, uint8_t* xs, size_t xsLen, uint8_t* ys, size_t ysLen) {
    size_t i;
    for (i = 0; i + xsOffset < xsLen && i < ysLen; i++) {
        if (xs[i + xsOffset] != ys[i]) {
            return i;
        }
    }
    return i;
}

uint8_t* extractProofValue(uint8_t rootHash[32], Bytes* path, RLPItem** stack, int stackLength) {
    Bytes *mptKey = _decodeNibbles(
        path, 0
    );

    int mptKeyOffset = 0;

    uint8_t nodeHashHash[32];

    RLPItem *rlpValue;

    if (stackLength == 0) {
        // Root hash of empty Merkle-Patricia-Trie
        if (memcmp(rootHash, "\x56\xe8\x1f\x17\x1b\xcc\x55\xa6\xff\x83\x45\xe6\x92\xc0\xf8\x6e\x5b\x48\xe0\x1b\x99\x6c\xad\xc0\x01\x62\x2f\xb5\xe3\x63\xb4\x21", 32) != 0) {
            exit(-1);
        }
        return 0;
    }

    for (int i = 0; i < stackLength; i++) {

        uint8_t calculatedNodeHashHash[32];

        mptHashHash(
            stack[i],
            calculatedNodeHashHash
        );

        printf("Iteration %d (nodeHashHash): ", i);
        printBytes32(nodeHashHash);
        printf("Iteration %d (calculatedNodeHashHash): ", i);
        printBytes32(calculatedNodeHashHash);
        
        if (i != 0 && memcmp(nodeHashHash, calculatedNodeHashHash, 32) != 0) {
            exit(-1);
        }

        uint32_t numItems;
        RLPItem **node = toList(stack[i], &numItems);

        if (numItems == 2) {
            printf("Inside numItems == 2\n");
            Bytes *nodeKey;

            Bytes *convertedNode = (Bytes*) malloc(sizeof(Bytes));

            convertedNode->data = toBytes(node[0]);
            convertedNode->length = node[0]->len;

            printf("Inside _merklePatriciaCompactDecode\n");

            int isLeaf = _merklePatriciaCompactDecode(convertedNode, nodeKey);

            printf("After _merklePatriciaCompactDecode\n");

            int prefixLength = _sharedPrefixLength(
                mptKeyOffset,
                mptKey->data,
                mptKey->length,
                nodeKey->data,
                nodeKey->length
            );

            mptKeyOffset += prefixLength;

            if (prefixLength < nodeKey->length) {
                if (i < stackLength - 1) {
                    exit(-1); // TODO: Should return bytes(0)
                }

                return 0; 
            }

            if (isLeaf) {
                if (i < stackLength - 1) {
                    exit(-1);
                }

                if (mptKeyOffset < mptKey->length) {
                    return 0;
                }

                rlpValue = node[1];
                return toBytes(rlpValue);
            } else {
                if (i == stackLength - 1) {
                    exit(-1);
                }

                if (!isList(node[1])) {
                    payloadKeccak256(node[1], nodeHashHash);
                } else {
                    keccak256(node[1]->memPtr, node[1]->len, nodeHashHash);
                }
            }

        } else if (numItems == 17) {

            if (mptKeyOffset != mptKey->length) {
                uint8_t nibble = mptKey->data[mptKeyOffset];
                mptKeyOffset += 1;

                if (nibble >= 16) {
                    exit(-1);
                }

                if (_isEmptyBytesequence(node[nibble])) {
                    if (i != stackLength - 1) {
                        exit(-1);
                    }

                    return 0; // TODO: Should return bytes(0)
                } else if (!isList(node[nibble])) {
                    payloadKeccak256(node[nibble], nodeHashHash);
                    printBytes32(nodeHashHash);
                } else {
                    keccak256(node[nibble]->memPtr, node[nibble]->len, nodeHashHash);
                }

            } else {
                return toBytes(node[16]);
            }
        }
    }

    free(mptKey->data);
    free(mptKey);

    return 0;
}

int main() {
    uint8_t rootHash[32] = {
        0xd3,0xa2,0xa6,0xd2,0x60,0x78,0xf9,0xf4,0xbe,0x12,0xf2,0x95,0x83,0x54,0x11,
        0xd4,0xf2,0xdb,0x4c,0x00,0xbb,0x1f,0xd1,0xfd,0x12,0x5f,0xe9,0x4f,0xf2,0x90,
        0xe8,0x61
    };

    uint8_t pathFixed[] = {0x67,0xc7,0xdc,0xde,0xcc,0xb2,0x5c,0xf8,0xd6,0x24,0x4d,0xf0,0x42,0xd4,0xf5,0xb0,0x89,0x59,0x06,0x03,0x5b,0x10,0xd6,0x1c,0x52,0x58,0xf4,0xe2,0x25,0x2f,0x72,0x06};

    Bytes *path = (Bytes *) malloc(sizeof(Bytes));
    path->data = (uint8_t*) malloc(sizeof(uint8_t) * sizeof(pathFixed));
    memcpy(path->data, pathFixed, sizeof(pathFixed));
    path->length = sizeof(pathFixed);

    RLPItem **rlpItems = (RLPItem **) malloc(sizeof(RLPItem*) * 16);

    uint8_t first_proof[] = {0xf9,0x02,0x11,0xa0,0xf4,0xc5,0xc0,0xc8,0x6a,0xed,0x65,0xa5,0xeb,0x36,0x1f,0x68,0x74,0x74,0xb7,0x13,0x4d,0xf3,0x41,0xbd,0x55,0x35,0xda,0x26,0x51,0x27,0xf9,0x41,0x52,0xb9,0xc0,0xf9,0xa0,0xb1,0x5d,0x7d,0xd0,0xb8,0x5c,0x22,0x7c,0x0e,0x2a,0x16,0x57,0x69,0x71,0xe2,0xbf,0x91,0x50,0xcd,0x30,0x5e,0x44,0xd7,0xad,0xd7,0xac,0x52,0xc6,0xf1,0x50,0x53,0x05,0xa0,0xcc,0xb5,0xc6,0xe6,0xc6,0xbe,0x75,0x42,0xcb,0x57,0x68,0xed,0x51,0x3e,0xe2,0x96,0x88,0xe6,0x44,0x8a,0xb0,0x47,0x1f,0x7b,0xee,0xc0,0xe4,0x5b,0x15,0x63,0x50,0x83,0xa0,0x2d,0x75,0x63,0x25,0x77,0x9c,0xe7,0x15,0xd5,0xcf,0xca,0xcf,0xd9,0xed,0xb9,0x6d,0x5d,0xc0,0x03,0x6b,0x9d,0xb0,0x3d,0xd5,0x7d,0x4e,0x23,0x84,0x5a,0xe0,0x71,0xf5,0xa0,0x7c,0xfd,0x68,0xc3,0x26,0xcb,0xb2,0xd9,0xcc,0xf3,0xac,0x07,0x26,0x72,0x0c,0x2c,0x6e,0x06,0x55,0x40,0xf5,0x85,0xf2,0xd4,0x7c,0x7d,0x1b,0xfe,0x2f,0x29,0xec,0xd5,0xa0,0x67,0x6c,0x8d,0x44,0x9b,0xbf,0x42,0xc9,0x28,0xfe,0xea,0xef,0xd6,0x8d,0xf2,0xbc,0x51,0x09,0x40,0x1a,0x12,0xb8,0xa3,0x14,0x6e,0xb3,0x76,0x28,0xc7,0x13,0x1b,0x7a,0xa0,0x62,0x12,0xa6,0x04,0xab,0x80,0x80,0xff,0x63,0x35,0x24,0xc4,0x7c,0xa1,0x3b,0xb8,0x2d,0x52,0x38,0x25,0x81,0x15,0xf6,0x92,0x94,0x74,0xb9,0xcd,0x72,0x40,0x5f,0x08,0xa0,0xbf,0x7b,0x2b,0x79,0x82,0x54,0xef,0x5e,0xe1,0x17,0x8a,0xcd,0x28,0xb0,0x50,0x23,0xf7,0x7b,0xed,0xd9,0x79,0xa0,0x77,0x3e,0x31,0x25,0x46,0x04,0x8e,0x77,0x5d,0xfb,0xa0,0x6e,0x2a,0x64,0x4c,0xc7,0x7b,0xd5,0x46,0xcd,0x87,0x8d,0x20,0xf6,0x52,0x89,0x33,0xe8,0xd9,0xc6,0xed,0xf9,0x94,0x4d,0x29,0x6d,0x18,0x1e,0x56,0xc0,0x01,0x32,0x85,0xa0,0xdc,0x31,0xd8,0x9e,0xb4,0x0c,0x00,0x4b,0x2a,0x1f,0xd0,0x70,0x46,0x99,0xdb,0x24,0xf0,0x86,0x0c,0x29,0x55,0xb8,0x66,0xbb,0x54,0x9e,0x6c,0x20,0xdd,0x23,0xb5,0x03,0xa0,0x39,0xee,0xfb,0x67,0x8f,0xb3,0xb7,0x01,0xb3,0x6e,0x11,0x64,0xc8,0xa4,0x1d,0x2c,0xe2,0xb2,0x55,0xe3,0xca,0x72,0xfa,0x61,0xf8,0xa3,0x33,0xfa,0xaf,0x6e,0xcb,0x79,0xa0,0x46,0x90,0x27,0x24,0x14,0xba,0xf9,0x06,0x82,0x7c,0x27,0x76,0xb3,0x10,0x31,0x77,0x91,0xc7,0xad,0x60,0xd8,0x5e,0xda,0xc8,0x2e,0x35,0xc0,0xfe,0x75,0x73,0xae,0x1e,0xa0,0xed,0xef,0x95,0x06,0x72,0x58,0xd1,0x70,0x64,0xa9,0xa0,0xda,0xcc,0xc2,0x1e,0x17,0xfa,0x61,0x9c,0xbb,0x9d,0x7b,0x3b,0xa6,0xb7,0xc0,0x95,0x58,0xfd,0x62,0x35,0x35,0xa0,0x6b,0xf6,0x18,0x70,0xe5,0x08,0x0b,0xc2,0xa2,0x76,0x3c,0x39,0x34,0x11,0x9b,0x39,0xc5,0x8b,0x5d,0xcb,0x53,0x25,0x22,0x32,0x6c,0x4c,0xfe,0x9b,0x34,0x01,0x96,0x56,0xa0,0xa6,0xfb,0x36,0xe4,0xec,0x57,0x56,0x15,0x0c,0x41,0xa3,0xbf,0x69,0x55,0x00,0x3a,0xa4,0xdb,0x46,0xd9,0x73,0x38,0x95,0x08,0x47,0x54,0x29,0x92,0x14,0x1c,0x78,0xce,0xa0,0xf1,0x57,0x13,0xc1,0xac,0x1d,0x53,0x3f,0x18,0x8e,0xe9,0xf5,0xc2,0x7f,0x48,0x9e,0x16,0x76,0x7e,0x47,0x05,0x94,0x2f,0xd0,0xe8,0xc0,0xba,0x67,0x82,0xb0,0xf2,0x8b,0x80};
    uint8_t second_proof[] = {0xf9,0x02,0x11,0xa0,0x7f,0xf1,0xad,0x5d,0x6a,0x43,0xbd,0x41,0x4f,0xbd,0x35,0xdc,0x03,0x0b,0x19,0x73,0x9f,0xc7,0xce,0x61,0xf7,0x06,0x0e,0x61,0xd9,0xd2,0x54,0x61,0xe3,0xca,0xd1,0x31,0xa0,0x9f,0xe9,0x6e,0xea,0xf1,0x6b,0xf4,0xc8,0x2e,0x46,0xc8,0x5d,0x91,0x92,0xa7,0xd3,0xd9,0xb0,0x1b,0xf8,0xd4,0xd0,0xb4,0xef,0xed,0xf1,0x4d,0xc1,0x84,0x29,0x26,0xdd,0xa0,0xe4,0x86,0xbf,0xe5,0x2e,0x93,0xde,0x01,0x80,0x05,0x12,0x47,0x31,0xac,0x8c,0x58,0xe5,0xb5,0x35,0xd4,0x90,0x78,0xfa,0xc5,0xb7,0x15,0x8d,0x62,0xb8,0x04,0x95,0x43,0xa0,0xb9,0x61,0xb2,0xa7,0xa3,0xd1,0x43,0xdd,0x4d,0xe2,0xba,0xce,0xaf,0x38,0x47,0xc0,0x8c,0x0d,0x4d,0xa5,0xc0,0x96,0x8c,0xe9,0xcc,0x3f,0x95,0xb5,0xa6,0x7b,0x0a,0xeb,0xa0,0xa9,0x81,0xd5,0x36,0x42,0x0b,0x09,0xca,0x2b,0xd1,0x3d,0xda,0xba,0x19,0x8f,0x7c,0xf9,0x6d,0x29,0xff,0xfa,0x44,0x8e,0x78,0x8f,0xdf,0x05,0xec,0x81,0x43,0x9d,0xd6,0xa0,0x87,0x87,0x43,0x0e,0x97,0xb5,0x6b,0xfb,0x38,0x28,0x6f,0xfe,0xc9,0x5f,0x98,0xc2,0x6f,0x01,0x0a,0x82,0xce,0xeb,0x35,0x43,0x6a,0xe3,0x80,0x2c,0xf9,0xe6,0xe4,0xf6,0xa0,0x5a,0x01,0x87,0x2d,0x0f,0x51,0x41,0x7a,0xd6,0x39,0x5d,0xcc,0xad,0xcd,0x13,0x80,0xb4,0xfc,0xd9,0x23,0x74,0xfe,0xf3,0x17,0x4d,0x06,0x1d,0xe4,0xf0,0x98,0xc7,0x38,0xa0,0x8b,0xb5,0x03,0x9f,0x2e,0xc6,0xdd,0x49,0xcc,0xe2,0x60,0x1d,0x35,0x7b,0x9e,0x44,0x97,0x4b,0x9f,0xcf,0xad,0xea,0xf5,0xee,0xb3,0x0f,0x4d,0x2c,0x16,0x4d,0xf5,0xa7,0xa0,0x52,0x19,0x69,0xc1,0xa1,0x4f,0x57,0x4b,0xb2,0xd2,0x4f,0xe0,0x3b,0xb6,0x93,0xd0,0x4f,0xa2,0xe0,0x31,0xb7,0x95,0xb1,0xe1,0x7b,0xc8,0xfd,0xe5,0x1a,0x29,0xb7,0xc7,0xa0,0x5f,0xcf,0xe3,0x89,0x59,0x8c,0x70,0x4d,0x9a,0x79,0xd7,0xe2,0x74,0x7e,0x80,0xa5,0x36,0xd4,0xac,0x6b,0x94,0x28,0xb8,0x42,0xd6,0x2f,0x01,0x17,0x04,0xe5,0xd5,0xb3,0xa0,0x4d,0xbe,0x64,0xd8,0x16,0x60,0x61,0x84,0xf3,0xcd,0x89,0xaf,0x4b,0x1c,0x51,0x3b,0x38,0x95,0x74,0x63,0x51,0x9a,0x42,0x97,0x5b,0x47,0x32,0x53,0x0f,0x99,0xb6,0xf9,0xa0,0x11,0xdd,0x52,0x77,0xca,0x38,0x90,0x0f,0x91,0x55,0xc5,0x5b,0xda,0x46,0x57,0x2b,0x93,0xae,0xfd,0x2c,0xbd,0x28,0x2a,0x6d,0xe8,0xd7,0x96,0x78,0x6c,0xf7,0x1b,0x0d,0xa0,0x3f,0x8d,0x42,0x7e,0xf8,0xd7,0x22,0xbe,0x5c,0xc7,0xf7,0x3c,0x1e,0x1e,0xd6,0xce,0xb3,0x7e,0x13,0x1b,0x0a,0x4d,0x61,0x0c,0x2f,0x37,0x06,0x34,0xed,0xa8,0x20,0xfa,0xa0,0x6d,0xa1,0xa8,0xb4,0x40,0xf2,0xa0,0x2e,0x82,0x35,0x3a,0x83,0xed,0xf1,0xf2,0xb7,0xb8,0xfc,0xed,0x70,0x3f,0xde,0x44,0x21,0xd8,0x20,0x3a,0x3d,0xed,0xc6,0x3b,0xd7,0xa0,0x46,0xf0,0xf0,0xcc,0x10,0x31,0x7e,0x99,0x12,0x41,0x5f,0x3f,0x63,0x32,0xeb,0xca,0x49,0x6a,0x0d,0xcf,0x57,0xbe,0x0b,0x38,0xb3,0xa4,0x66,0x83,0x45,0x50,0xc6,0xd1,0xa0,0x9b,0xcb,0x37,0xde,0x0e,0xb0,0x91,0x60,0xa1,0x05,0x2e,0xc8,0xc2,0x8d,0xe5,0x1f,0x69,0x59,0xec,0x78,0xba,0xf3,0x25,0xd1,0x98,0x43,0x94,0x1f,0xb8,0x2f,0x0d,0x96,0x80};
    uint8_t third_proof[] = {0xf9,0x02,0x11,0xa0,0x6b,0xc8,0x7a,0x42,0xd3,0x0e,0x98,0xf0,0xf4,0x98,0x4f,0x9e,0xcc,0x9a,0xa8,0x32,0x2b,0x99,0x9f,0x4e,0x50,0x90,0x14,0x45,0xfe,0x91,0x95,0x05,0x0e,0x7e,0x1e,0x17,0xa0,0xd3,0x05,0x67,0x92,0x7d,0x08,0xea,0x12,0x9e,0xb5,0x88,0xe3,0x8a,0x58,0x86,0x4c,0x75,0xb1,0x31,0xf7,0x29,0x3e,0x89,0xd7,0xfa,0x9e,0xc2,0x39,0xbc,0xc0,0x50,0xa4,0xa0,0x32,0x86,0xe4,0x97,0x9f,0xc4,0xf2,0xa0,0x37,0x7e,0x3b,0xb4,0xd7,0xa1,0x54,0x74,0x06,0x9a,0x13,0x45,0x60,0x1a,0xa1,0xdf,0xa6,0x90,0x3a,0x71,0xd5,0xe3,0xc7,0xf4,0xa0,0xb9,0x4d,0x1a,0x0b,0x44,0xfe,0xde,0x2c,0x48,0xf8,0x75,0x2c,0x3b,0x5d,0x78,0x10,0xa0,0x66,0xdd,0x2d,0x0e,0x96,0xf3,0xac,0x9d,0xfe,0x1d,0x5b,0xf4,0x26,0x5d,0x00,0xa0,0x5e,0xa7,0x79,0x4b,0x5c,0x64,0x14,0x24,0x18,0x9d,0x0f,0xca,0xb8,0x97,0x92,0x21,0xc2,0xf5,0x53,0xaf,0x56,0x9c,0xdd,0x02,0xc7,0x66,0xef,0x11,0x2d,0x71,0x87,0x81,0xa0,0x37,0x05,0x50,0x86,0x9d,0xe2,0x81,0x8b,0xf1,0x9d,0x20,0xce,0xfb,0x74,0xdf,0x7d,0x0e,0x88,0x16,0x4b,0x03,0x2d,0x57,0xce,0xc7,0x82,0xda,0xf4,0xbe,0xa3,0x30,0x58,0xa0,0x3d,0x00,0x71,0xe8,0xb6,0x53,0x39,0x45,0xc9,0x41,0xcf,0xd5,0x95,0x56,0xf1,0x89,0x52,0x11,0x02,0xfd,0x70,0x88,0x70,0xee,0x35,0xc6,0xbe,0x5a,0x6f,0xaa,0x8c,0x8a,0xa0,0x4e,0xf3,0x05,0xc8,0xf3,0x37,0x0f,0x24,0xaa,0x34,0xc0,0x6c,0x25,0xb6,0x60,0x14,0x69,0x46,0xc3,0xd1,0xd2,0x38,0x95,0x1a,0x53,0xd7,0x34,0x54,0x72,0xa3,0xaf,0xc0,0xa0,0x66,0x9c,0x57,0x6f,0x48,0xb2,0xa5,0x81,0x50,0xef,0x0e,0x78,0xf9,0x15,0x70,0x3b,0x29,0x65,0x11,0x43,0xf6,0x73,0xab,0x63,0xc0,0x5d,0xdb,0xa8,0xc8,0x9a,0x62,0x69,0xa0,0x0b,0xb3,0xc7,0xe8,0x1a,0xc3,0x12,0x93,0xbf,0x19,0x1c,0xcf,0x3e,0x57,0xd2,0x02,0x4f,0xb5,0x9d,0xd4,0x9a,0x6d,0x99,0x0d,0x72,0x6a,0x14,0x2c,0x42,0x3d,0x65,0x90,0xa0,0x27,0x06,0x60,0x95,0x5e,0x6e,0xf6,0x73,0x01,0x96,0x08,0x00,0xda,0x56,0x90,0x81,0x23,0x32,0x1e,0x6a,0x91,0xf1,0xea,0xf1,0x4f,0x10,0x3d,0x6a,0x99,0x66,0x64,0x2e,0xa0,0x5f,0x51,0x2b,0x96,0xe2,0x98,0xb7,0x49,0x6a,0xb3,0xcb,0xd9,0x4a,0x2e,0x6c,0x89,0xb3,0x95,0xcb,0x48,0x19,0x7a,0xb3,0xc1,0x78,0xe2,0x59,0xbe,0x82,0xa1,0xe8,0xd6,0xa0,0x29,0xf5,0x19,0x9e,0x17,0x0b,0x94,0xfe,0xc7,0x7a,0x12,0xa3,0xfb,0xcf,0xb1,0x49,0x98,0x21,0x75,0xb3,0xc9,0x6f,0x06,0xc3,0xa9,0x76,0xaf,0x30,0xe6,0xbf,0x2f,0xa0,0xa0,0xd1,0x53,0x96,0x09,0x17,0x78,0xff,0x22,0x35,0xbb,0x61,0x5f,0x69,0xc6,0x61,0x34,0x08,0xf6,0x66,0x90,0x40,0xec,0xbe,0xbc,0x95,0x34,0x33,0xea,0xe2,0xea,0x35,0x1b,0xa0,0x95,0x71,0xbb,0xbb,0x82,0x55,0x0f,0xfd,0xd4,0xd9,0x50,0x8a,0xa7,0xb0,0x23,0xbb,0xfd,0x45,0x2f,0xb0,0x17,0x3d,0x63,0xfe,0x89,0xd1,0x02,0x70,0x3a,0xd7,0xdb,0x5b,0xa0,0xcb,0xe3,0xca,0xb8,0x5e,0x12,0x08,0xb5,0xff,0x3d,0xec,0xf2,0x89,0x3d,0xbf,0x6c,0x73,0xf7,0x70,0x42,0x75,0x70,0x7a,0xce,0xe7,0x28,0xb7,0x75,0x81,0xf4,0xdf,0x48,0x80};
    uint8_t fourth_proof[] = {0xf9,0x02,0x11,0xa0,0x89,0x0a,0x0a,0x28,0xa6,0x6f,0x93,0xfb,0x32,0xd6,0xb0,0x30,0x9a,0x8a,0xfa,0x42,0xa1,0x19,0x10,0x30,0xdf,0x21,0x23,0x03,0xd7,0x95,0xc2,0x36,0xd6,0xb6,0xf4,0x3b,0xa0,0x0d,0xe1,0xc4,0x86,0xb9,0xe4,0x04,0x93,0x4c,0xc6,0xc8,0xfa,0x4c,0x85,0xec,0x6a,0x7c,0x2f,0xf0,0xd8,0xab,0x2c,0x8a,0x0e,0x5a,0xa7,0x0e,0x9d,0x05,0x07,0xe4,0xc7,0xa0,0x14,0x69,0x2a,0x00,0x52,0x0a,0xa8,0xf3,0x90,0xf5,0x41,0xad,0x8b,0xea,0x6e,0x26,0x86,0xdb,0x82,0x7b,0x07,0x5b,0xc2,0x38,0xda,0x73,0x29,0x0d,0x9b,0x04,0x18,0x3e,0xa0,0x1b,0x37,0xc8,0x67,0x01,0x48,0x90,0x00,0x0f,0xdb,0x76,0x59,0x1c,0x89,0xe2,0x1a,0xa0,0x51,0xf9,0xd5,0xb5,0x03,0x68,0x23,0x72,0x79,0x30,0x15,0xde,0xbc,0xa9,0x5a,0xa0,0xcb,0x87,0xcf,0x3c,0xfd,0x57,0xbf,0x94,0xe9,0x1c,0x14,0x46,0xfd,0x95,0x03,0xc1,0xe4,0x5e,0xe7,0x6d,0x8b,0xa3,0xd7,0x0b,0xfd,0x66,0x63,0x80,0x9b,0x82,0x7e,0x40,0xa0,0x5e,0x89,0x3d,0xa9,0x0f,0xe5,0x8d,0xdf,0xe2,0x1b,0xac,0xe6,0x56,0x0a,0xef,0xae,0x08,0x62,0x07,0x9a,0x83,0xac,0x81,0x3f,0x1f,0x61,0x16,0x7a,0x31,0xd1,0x21,0x64,0xa0,0xa8,0x5e,0x41,0x37,0x99,0xaf,0x74,0xee,0x3b,0x68,0xc4,0xe6,0xf1,0xe8,0xea,0xc6,0x40,0x3a,0x26,0x34,0x1b,0x7d,0xe2,0x0c,0xcf,0x3e,0xf5,0xfd,0x17,0x00,0xf0,0x9e,0xa0,0xa1,0x38,0x47,0x75,0x0e,0x17,0xaa,0x18,0x6e,0x7d,0xbf,0x31,0x72,0x60,0xa5,0x6c,0x07,0xee,0x39,0xaf,0x03,0x25,0x56,0x42,0x6e,0x6b,0x69,0x7d,0x09,0x18,0xae,0x49,0xa0,0x3a,0xc4,0x99,0x7c,0xa1,0xeb,0xbb,0xca,0xc8,0x4e,0x9a,0x6b,0x34,0xdc,0xcf,0x8f,0x0c,0x79,0xf1,0xe8,0x9b,0x10,0x94,0x59,0xa4,0xe5,0x2e,0x55,0x5c,0x83,0xd2,0xd6,0xa0,0x50,0x8a,0x64,0xc5,0x15,0x9f,0xae,0xeb,0xf7,0xa0,0x0c,0x69,0xd3,0xe2,0xe8,0x0f,0xce,0x8b,0x76,0x26,0xdd,0x35,0xff,0xfb,0x6e,0x62,0x16,0x65,0x8b,0x28,0x3c,0xd5,0xa0,0x8d,0xd7,0x8f,0xbe,0x96,0xae,0xff,0x73,0x80,0x8c,0x63,0x7d,0x2b,0xf4,0x6e,0xdb,0x81,0xeb,0xb3,0xd3,0x86,0x00,0x69,0xe8,0x6a,0x08,0xf6,0x6b,0xa4,0x6c,0x19,0xae,0xa0,0x39,0x20,0xbd,0x60,0xef,0x1a,0x4a,0x7e,0xb9,0x2d,0xf4,0x5f,0x01,0x5c,0x42,0x7a,0x51,0x3c,0x4f,0x4a,0x32,0xb8,0xf1,0xa2,0x7e,0x8c,0x84,0x9b,0xdc,0x03,0xa3,0x39,0xa0,0xbb,0x10,0x74,0x09,0xcf,0x01,0xbf,0x70,0x96,0xf6,0x27,0xe2,0x07,0x25,0xfc,0x5b,0x26,0xa6,0xae,0x1f,0x67,0x4a,0x2f,0x6b,0xb9,0x65,0xee,0xf3,0x22,0x96,0xb9,0x33,0xa0,0xf1,0x83,0x9c,0x6c,0xac,0x38,0xba,0x36,0x46,0xd5,0x83,0x90,0x45,0x5a,0xc8,0x0e,0xfa,0x91,0xb3,0xb8,0xe1,0x3b,0x6b,0x7d,0xac,0x83,0x77,0x61,0xee,0xe5,0xf4,0xa9,0xa0,0x21,0x7b,0xaf,0xc0,0xc2,0x18,0xa9,0x6c,0xf1,0xab,0x75,0x7e,0x9a,0x5b,0xae,0x20,0x0f,0x16,0x34,0x07,0x5d,0xe6,0x45,0x36,0x66,0x1d,0xc8,0x5c,0x22,0xc0,0x2e,0x3c,0xa0,0xe1,0x9b,0xac,0xa6,0xa0,0x0e,0x41,0xcb,0xa4,0xe4,0x70,0x33,0x6c,0x48,0xf1,0xff,0x11,0xc6,0x33,0xcc,0x88,0x84,0x01,0xf8,0x4a,0xe2,0xa6,0xe2,0xd6,0x3a,0xd1,0xa5,0x80};
    uint8_t fifth_proof[] = {0xf8,0x71,0xa0,0x33,0xdf,0x9a,0xfc,0xd4,0x5a,0xef,0xdb,0x90,0x09,0xdc,0x7b,0xe4,0xb8,0x3a,0x68,0x0a,0x7a,0x45,0x4a,0x40,0xac,0xef,0xf0,0xa8,0xd9,0x09,0x11,0x7b,0xdd,0xee,0xc7,0x80,0x80,0x80,0x80,0x80,0x80,0xa0,0x94,0x42,0x84,0x87,0x37,0xad,0xa0,0xc1,0xab,0x83,0xb3,0x34,0x93,0x90,0x51,0x1f,0x8e,0xb3,0x3a,0xe7,0x28,0x05,0x89,0xd8,0x6f,0xb6,0x11,0x4f,0x23,0x28,0x59,0xde,0x80,0x80,0x80,0x80,0x80,0x80,0xa0,0x95,0x4e,0x85,0x45,0xcb,0x42,0xac,0x37,0xf2,0xef,0x0f,0x79,0xf7,0x45,0xa0,0x3c,0x66,0x0d,0xd1,0x43,0xa7,0xb6,0x21,0x13,0x23,0x85,0x06,0x0a,0x83,0x45,0xe8,0x21,0x80,0x80};
    uint8_t sixth_proof[] = {0xe0,0x9e,0x3c,0xd9,0x54,0x8b,0x62,0xa8,0xd6,0x03,0x45,0xa9,0x88,0x38,0x6f,0xc8,0x4b,0xa6,0xbc,0x95,0x48,0x40,0x08,0xf6,0x36,0x2f,0x93,0x16,0x0e,0xf3,0xe5,0x63,0x01};

    uint8_t **proofs = malloc(6 * sizeof(uint8_t*));
    proofs[0] = first_proof;
    proofs[1] = second_proof;
    proofs[2] = third_proof;
    proofs[3] = fourth_proof;
    proofs[4] = fifth_proof;
    proofs[5] = sixth_proof;

    int sizes[6] = {
        sizeof(first_proof),
        sizeof(second_proof),
        sizeof(third_proof),
        sizeof(fourth_proof),
        sizeof(fifth_proof),
        sizeof(sixth_proof)
    };

    for (int i = 0; i < 6; i++) {
        rlpItems[i] = (RLPItem*) malloc(sizeof(RLPItem));
        rlpItems[i]->memPtr = (uint8_t*) malloc(sizes[i]);
        rlpItems[i]->len = sizes[i];

        memcpy(rlpItems[i]->memPtr, proofs[i], sizes[i]);
    }

    extractProofValue(rootHash, path, rlpItems, 6);

    free(path->data);
    free(path);

    for (int i = 0; i < 16; i++) {
        free(rlpItems[i]->memPtr);
        free(rlpItems[i]);
    }

    free(rlpItems);


    // printBytes32(pathFixedLength[0]);

    // for (int i = 0; i < 16; i++) {
    //     SHA3_CTX context;
    //     keccak_init(&context);
    //     keccak_update(&context, (const unsigned char*)pathFixedLength[i], (size_t)32);

    //     uint8_t result[32];

    //     keccak_final(&context, (unsigned char*)result);

    //     printBytes32(result);

    //     memset((char*)&context, 0, sizeof(SHA3_CTX));
    // }

    return 0;
}

/*

State root(bytes32) = {0xd3,0xa2,0xa6,0xd2,0x60,0x78,0xf9,0xf4,0xbe,0x12,0xf2,0x95,0x83,0x54,0x11,0xd4,0xf2,0xdb,0x4c,0x0,0xbb,0x1f,0xd1,0xfd,0x12,0x5f,0xe9,0x4f,0xf2,0x90,0xe8,0x61};
Value= 0x01;
proof = {
Proof:
{0xf4,0xc5,0xc0,0xc8,0x6a,0xed,0x65,0xa5,0xeb,0x36,0x1f,0x68,0x74,0x74,0xb7,0x13,0x4d,0xf3,0x41,0xbd,0x55,0x35,0xda,0x26,0x51,0x27,0xf9,0x41,0x52,0xb9,0xc0,0xf9},
{0xb1,0x5d,0x7d,0xd0,0xb8,0x5c,0x22,0x7c,0xe,0x2a,0x16,0x57,0x69,0x71,0xe2,0xbf,0x91,0x50,0xcd,0x30,0x5e,0x44,0xd7,0xad,0xd7,0xac,0x52,0xc6,0xf1,0x50,0x53,0x5},
{0xcc,0xb5,0xc6,0xe6,0xc6,0xbe,0x75,0x42,0xcb,0x57,0x68,0xed,0x51,0x3e,0xe2,0x96,0x88,0xe6,0x44,0x8a,0xb0,0x47,0x1f,0x7b,0xee,0xc0,0xe4,0x5b,0x15,0x63,0x50,0x83},
{0x2d,0x75,0x63,0x25,0x77,0x9c,0xe7,0x15,0xd5,0xcf,0xca,0xcf,0xd9,0xed,0xb9,0x6d,0x5d,0xc0,0x3,0x6b,0x9d,0xb0,0x3d,0xd5,0x7d,0x4e,0x23,0x84,0x5a,0xe0,0x71,0xf5},
{0x7c,0xfd,0x68,0xc3,0x26,0xcb,0xb2,0xd9,0xcc,0xf3,0xac,0x7,0x26,0x72,0xc,0x2c,0x6e,0x6,0x55,0x40,0xf5,0x85,0xf2,0xd4,0x7c,0x7d,0x1b,0xfe,0x2f,0x29,0xec,0xd5},
{0x67,0x6c,0x8d,0x44,0x9b,0xbf,0x42,0xc9,0x28,0xfe,0xea,0xef,0xd6,0x8d,0xf2,0xbc,0x51,0x9,0x40,0x1a,0x12,0xb8,0xa3,0x14,0x6e,0xb3,0x76,0x28,0xc7,0x13,0x1b,0x7a},
{0x62,0x12,0xa6,0x4,0xab,0x80,0x80,0xff,0x63,0x35,0x24,0xc4,0x7c,0xa1,0x3b,0xb8,0x2d,0x52,0x38,0x25,0x81,0x15,0xf6,0x92,0x94,0x74,0xb9,0xcd,0x72,0x40,0x5f,0x8},
{0xbf,0x7b,0x2b,0x79,0x82,0x54,0xef,0x5e,0xe1,0x17,0x8a,0xcd,0x28,0xb0,0x50,0x23,0xf7,0x7b,0xed,0xd9,0x79,0xa0,0x77,0x3e,0x31,0x25,0x46,0x4,0x8e,0x77,0x5d,0xfb},
{0x6e,0x2a,0x64,0x4c,0xc7,0x7b,0xd5,0x46,0xcd,0x87,0x8d,0x20,0xf6,0x52,0x89,0x33,0xe8,0xd9,0xc6,0xed,0xf9,0x94,0x4d,0x29,0x6d,0x18,0x1e,0x56,0xc0,0x1,0x32,0x85},
{0xdc,0x31,0xd8,0x9e,0xb4,0xc,0x0,0x4b,0x2a,0x1f,0xd0,0x70,0x46,0x99,0xdb,0x24,0xf0,0x86,0xc,0x29,0x55,0xb8,0x66,0xbb,0x54,0x9e,0x6c,0x20,0xdd,0x23,0xb5,0x3},
{0x39,0xee,0xfb,0x67,0x8f,0xb3,0xb7,0x1,0xb3,0x6e,0x11,0x64,0xc8,0xa4,0x1d,0x2c,0xe2,0xb2,0x55,0xe3,0xca,0x72,0xfa,0x61,0xf8,0xa3,0x33,0xfa,0xaf,0x6e,0xcb,0x79},
{0x46,0x90,0x27,0x24,0x14,0xba,0xf9,0x6,0x82,0x7c,0x27,0x76,0xb3,0x10,0x31,0x77,0x91,0xc7,0xad,0x60,0xd8,0x5e,0xda,0xc8,0x2e,0x35,0xc0,0xfe,0x75,0x73,0xae,0x1e},
{0xed,0xef,0x95,0x6,0x72,0x58,0xd1,0x70,0x64,0xa9,0xa0,0xda,0xcc,0xc2,0x1e,0x17,0xfa,0x61,0x9c,0xbb,0x9d,0x7b,0x3b,0xa6,0xb7,0xc0,0x95,0x58,0xfd,0x62,0x35,0x35},
{0x6b,0xf6,0x18,0x70,0xe5,0x8,0xb,0xc2,0xa2,0x76,0x3c,0x39,0x34,0x11,0x9b,0x39,0xc5,0x8b,0x5d,0xcb,0x53,0x25,0x22,0x32,0x6c,0x4c,0xfe,0x9b,0x34,0x1,0x96,0x56},
{0xa6,0xfb,0x36,0xe4,0xec,0x57,0x56,0x15,0xc,0x41,0xa3,0xbf,0x69,0x55,0x0,0x3a,0xa4,0xdb,0x46,0xd9,0x73,0x38,0x95,0x8,0x47,0x54,0x29,0x92,0x14,0x1c,0x78,0xce},
{0xf1,0x57,0x13,0xc1,0xac,0x1d,0x53,0x3f,0x18,0x8e,0xe9,0xf5,0xc2,0x7f,0x48,0x9e,0x16,0x76,0x7e,0x47,0x5,0x94,0x2f,0xd0,0xe8,0xc0,0xba,0x67,0x82,0xb0,0xf2,0x8b},
};


["0xf4c5c0c86aed65a5eb361f687474b7134df341bd5535da265127f94152b9c0f9", "0xb15d7dd0b85c227c0e2a16576971e2bf9150cd305e44d7add7ac52c6f1505305", "0xccb5c6e6c6be7542cb5768ed513ee29688e6448ab0471f7beec0e45b15635083", "0x2d756325779ce715d5cfcacfd9edb96d5dc0036b9db03dd57d4e23845ae071f5", "0x7cfd68c326cbb2d9ccf3ac0726720c2c6e065540f585f2d47c7d1bfe2f29ecd5", "0x676c8d449bbf42c928feeaefd68df2bc5109401a12b8a3146eb37628c7131b7a", "0x6212a604ab8080ff633524c47ca13bb82d5238258115f6929474b9cd72405f08", "0xbf7b2b798254ef5ee1178acd28b05023f77bedd979a0773e312546048e775dfb", "0x6e2a644cc77bd546cd878d20f6528933e8d9c6edf9944d296d181e56c0013285", "0xdc31d89eb40c004b2a1fd0704699db24f0860c2955b866bb549e6c20dd23b503", "0x39eefb678fb3b701b36e1164c8a41d2ce2b255e3ca72fa61f8a333faaf6ecb79", "0x4690272414baf906827c2776b310317791c7ad60d85edac82e35c0fe7573ae1e", "0xedef95067258d17064a9a0daccc21e17fa619cbb9d7b3ba6b7c09558fd623535", "0x6bf61870e5080bc2a2763c3934119b39c58b5dcb532522326c4cfe9b34019656", "0xa6fb36e4ec5756150c41a3bf6955003aa4db46d97338950847542992141c78ce", "0xf15713c1ac1d533f188ee9f5c27f489e16767e4705942fd0e8c0ba6782b0f28b", "0x00"]


RLP-encoded proof:

{0xf9,0x02,0x11,0xa0,0x9e,0x6c,0x49,0x07,0x44,0xa1,0x55,0xe1,0x96,0x01,0xef,0xec,0x43,0x25,0xfb,0x8c,0x03,0x15,0x35,0x6b,0xa5,0xf0,0x39,0xc9,0x4a,0xdf,0x57,0x05,0xa8,0x1b,0x74,0x0e,0xa0,0xec,0xf6,0x10,0xbd,0x60,0x77,0xbb,0xcd,0xa8,0x5f,0x3d,0xa7,0x26,0x1c,0x04,0x2d,0xbf,0x97,0x9a,0xda,0xc6,0x68,0x7c,0x84,0xd1,0xde,0x11,0x66,0x71,0x01,0x33,0x50,0xa0,0x86,0xb7,0x90,0xdd,0xd1,0x39,0x4d,0x37,0xed,0xc9,0xb1,0xf1,0x2e,0x94,0xe4,0x22,0xc4,0x27,0xe2,0xb2,0x0f,0x91,0x92,0x17,0xce,0x42,0x0d,0x5c,0x52,0x22,0xcb,0x56,0xa0,0xa8,0x3a,0xc6,0x52,0x02,0xc0,0xc3,0xb9,0xc5,0xe0,0xfa,0x08,0x9d,0x72,0x3a,0x49,0x75,0xf0,0x62,0x78,0x33,0x9f,0x60,0xa6,0xf7,0xe7,0xea,0x8d,0x93,0x50,0xc3,0x70,0xa0,0x41,0xfa,0xe4,0x38,0x64,0xc2,0x71,0x45,0x37,0x3a,0x78,0xa6,0xa7,0x1f,0x2b,0x41,0x24,0x23,0x6e,0x32,0x16,0xd5,0x31,0x53,0xd1,0x25,0x61,0xda,0x3e,0xe5,0x38,0x1f,0xa0,0x4c,0xbd,0xdb,0x83,0x9f,0xdf,0x96,0x8d,0x69,0x3f,0x70,0x9e,0x94,0x12,0x84,0x99,0x2e,0xc0,0x59,0x94,0x15,0x12,0x8d,0x62,0x81,0xe4,0x8f,0x73,0xdb,0x99,0x1d,0x27,0xa0,0x34,0x6f,0xe7,0xaf,0x2d,0xf0,0x91,0x4a,0x56,0x79,0x51,0x26,0x5d,0x96,0xd9,0xbc,0x65,0xa0,0xa4,0x19,0x78,0x76,0x4a,0xdb,0x27,0xf2,0x59,0x37,0x58,0xdf,0xfd,0x0e,0xa0,0xff,0x66,0x04,0x6b,0x63,0xe4,0xf5,0x6c,0x09,0xda,0xdb,0x13,0xef,0x68,0x2c,0x0a,0x50,0x50,0x07,0x38,0x17,0xb9,0x73,0x01,0x64,0x45,0xae,0x2c,0xb4,0xf9,0x82,0x2a,0xa0,0x67,0xfd,0x75,0xd1,0xae,0xe3,0x5d,0xc6,0x82,0xbc,0x85,0xe8,0xd6,0xc4,0x5b,0x7a,0x40,0xfa,0x84,0xf1,0x9b,0x5e,0x57,0x6d,0x92,0xdb,0x8f,0x18,0xa6,0x3a,0x2f,0xf1,0xa0,0x0a,0x01,0xe9,0x8a,0x93,0x30,0x58,0x98,0xa4,0xa5,0x5f,0xc3,0x9e,0xa2,0xa3,0xb1,0x7f,0x2c,0x01,0x5e,0x80,0xb5,0x15,0xf3,0xb7,0x0b,0x07,0x6d,0xbf,0x37,0x8a,0x32,0xa0,0x1a,0x4f,0xc8,0x40,0x86,0xe7,0x0d,0xa3,0x80,0x94,0x6c,0xf8,0x51,0x29,0xf6,0x6e,0xc1,0xe7,0xb1,0x16,0xb8,0x5a,0x4c,0x24,0x3f,0xd5,0x56,0x51,0x8c,0x4f,0xbd,0xab,0xa0,0xff,0xfe,0x64,0x46,0xa7,0xf6,0x9f,0x3d,0xf7,0xe5,0xc8,0xf0,0x50,0x1b,0xbf,0xbf,0x38,0xbc,0xee,0x4e,0x71,0x95,0xff,0x58,0x10,0x50,0x0d,0x24,0x3e,0x34,0x17,0x0a,0xa0,0x6c,0xf8,0x43,0xf2,0x86,0xe4,0x76,0xee,0xf6,0x16,0xa3,0x55,0x41,0x51,0x8f,0x3c,0x2e,0xad,0xe7,0x68,0xc4,0x0c,0xbb,0x86,0x89,0x15,0x01,0x56,0x71,0x2e,0x75,0xcf,0xa0,0xdd,0x1f,0x58,0xfe,0xe5,0x97,0xfe,0x82,0xd8,0x99,0x55,0x5b,0x93,0x00,0x7e,0x9c,0x88,0xb2,0x4d,0x7f,0x1f,0xfa,0xe7,0xff,0x26,0xa5,0x78,0x25,0x5a,0x50,0xf9,0xe4,0xa0,0x24,0xc8,0x12,0x9e,0xef,0x18,0x96,0x96,0x93,0x63,0xf1,0x6b,0x42,0x66,0x63,0x10,0xc8,0x10,0x12,0x54,0x2f,0x8d,0x63,0x24,0xdd,0xb4,0x7f,0x0a,0x3b,0xd2,0x56,0x1d,0xa0,0x9d,0xbe,0x0a,0x2f,0xfd,0xde,0x6d,0x81,0x51,0xc4,0xd7,0xa5,0xb3,0x23,0xb8,0x8a,0x78,0x25,0x5b,0x07,0x75,0xf4,0xbd,0x05,0x0a,0x45,0xad,0x9a,0xd5,0xd1,0xc5,0xc5,0x80}



*/